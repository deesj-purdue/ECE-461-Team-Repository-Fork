"""
Test runner with pytest integration and coverage reporting.
"""

import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional


class TestExecutionResult:
    """Test execution results with coverage data.

    This class stores the results of running tests with coverage reporting.
    Note: Renamed from TestResult to avoid pytest collection warnings.
    """

    def __init__(
        self,
        exit_code: int,
        tests_run: int,
        tests_passed: int,
        tests_failed: int,
        coverage_percentage: float,
        coverage_report: Dict[str, float],
        execution_time: float,
        ndjson_output: str,
    ):
        self.exit_code = exit_code
        self.tests_run = tests_run
        self.tests_passed = tests_passed
        self.tests_failed = tests_failed
        self.coverage_percentage = coverage_percentage
        self.coverage_report = coverage_report
        self.execution_time = execution_time
        self.ndjson_output = ndjson_output


class RunTest:
    """Test runner with pytest integration and coverage reporting."""

    def __init__(self, project_root: Optional[str] = None):
        """Initialize test runner.

        Args:
            project_root: Root directory of the project.
                Defaults to current directory.
        """
        self.project_root = Path(project_root) if project_root else Path.cwd()
        self.src_dir = self.project_root / "src"
        self.tests_dir = self.project_root / "tests"

    def run_tests_with_coverage(
        self, test_pattern: Optional[str] = None, min_coverage: float = 10.0
    ) -> TestExecutionResult:
        """Run pytest with coverage reporting.

        Args:
            test_pattern: Optional pattern to filter tests
            min_coverage: Minimum coverage percentage required

        Returns:
            TestExecutionResult object with execution details
        """
        # Build pytest command
        cmd = [
            sys.executable,
            "-m",
            "pytest",
            "--cov=src",  # Coverage for src directory
            "--cov-report=json",  # JSON coverage output
            "--cov-report=term-missing",  # Terminal coverage report
            "--tb=short",  # Short traceback format
            "-v",  # Verbose output
        ]

        # Add test pattern if specified
        if test_pattern:
            cmd.append(test_pattern)
        else:
            cmd.append(str(self.tests_dir))

        # Add coverage fail threshold
        cmd.extend([f"--cov-fail-under={min_coverage}"])

        try:
            # Run pytest
            result = subprocess.run(
                cmd,
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout
            )

            # Parse coverage report
            coverage_data = self._parse_coverage_report()

            # Parse test results from output
            test_stats = self._parse_test_output(result.stdout)

            # Generate NDJSON output
            ndjson_output = self._generate_ndjson_output(
                test_stats, coverage_data, result.returncode
            )

            return TestExecutionResult(
                exit_code=result.returncode,
                tests_run=test_stats.get("total", 0),
                tests_passed=test_stats.get("passed", 0),
                tests_failed=test_stats.get("failed", 0),
                coverage_percentage=coverage_data.get("totals", {}).get(
                    "percent_covered", 0.0
                ),
                coverage_report=self._extract_file_coverage(coverage_data),
                execution_time=test_stats.get("duration", 0.0),
                ndjson_output=ndjson_output,
            )

        except subprocess.TimeoutExpired:
            return TestExecutionResult(
                exit_code=124,  # Timeout exit code
                tests_run=0,
                tests_passed=0,
                tests_failed=0,
                coverage_percentage=0.0,
                coverage_report={},
                execution_time=300.0,
                ndjson_output=self._generate_error_ndjson(
                    "Test execution timeout"
                ),
            )
        except Exception as e:
            return TestExecutionResult(
                exit_code=1,
                tests_run=0,
                tests_passed=0,
                tests_failed=0,
                coverage_percentage=0.0,
                coverage_report={},
                execution_time=0.0,
                ndjson_output=self._generate_error_ndjson(str(e)),
            )

    def _parse_coverage_report(self) -> Dict:
        """Parse JSON coverage report generated by pytest-cov."""
        coverage_file = self.project_root / "coverage.json"
        if not coverage_file.exists():
            return {}

        try:
            with open(coverage_file, "r") as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return {}

    def _parse_test_output(self, output: str) -> Dict[str, int]:
        """Parse pytest output to extract test statistics."""
        stats = {"total": 0, "passed": 0, "failed": 0, "duration": 0.0}

        lines = output.split("\n")
        for line in lines:
            # Look for summary line like "169 passed, 1 warning in 0.53s"
            if "passed" in line and "in" in line and "s" in line:
                parts = line.split()
                for i, part in enumerate(parts):
                    if part.startswith("passed") and i > 0:
                        try:
                            stats["passed"] = int(parts[i - 1])
                            stats["total"] += stats["passed"]
                        except (ValueError, IndexError):
                            pass
                    elif part.startswith("failed") and i > 0:
                        try:
                            stats["failed"] = int(parts[i - 1])
                            stats["total"] += stats["failed"]
                        except (ValueError, IndexError):
                            pass
                    elif part.endswith("s") and "in" in parts[i - 1: i + 1]:
                        try:
                            stats["duration"] = float(part[:-1])
                        except ValueError:
                            pass
                break

        return stats

    def _extract_file_coverage(self, coverage_data: Dict) -> Dict[str, float]:
        """Extract per-file coverage percentages."""
        file_coverage = {}

        files = coverage_data.get("files", {})
        for filepath, file_data in files.items():
            summary = file_data.get("summary", {})
            percent_covered = summary.get("percent_covered", 0.0)

            # Convert absolute path to relative path from src
            if filepath.startswith(str(self.src_dir)):
                rel_path = os.path.relpath(filepath, self.src_dir)
                file_coverage[rel_path] = percent_covered
            else:
                file_coverage[filepath] = percent_covered

        return file_coverage

    def _generate_ndjson_output(
        self, test_stats: Dict, coverage_data: Dict, exit_code: int
    ) -> str:
        """Generate NDJSON formatted test results."""
        totals = coverage_data.get("totals", {})
        result = {
            "test_execution": {
                "status": "success" if exit_code == 0 else "failure",
                "exit_code": exit_code,
                "tests_run": test_stats.get("total", 0),
                "tests_passed": test_stats.get("passed", 0),
                "tests_failed": test_stats.get("failed", 0),
                "execution_time": test_stats.get("duration", 0.0),
            },
            "coverage": {
                "overall_percentage": totals.get("percent_covered", 0.0),
                "files_covered": len(coverage_data.get("files", {})),
                "lines_covered": totals.get("covered_lines", 0),
                "lines_total": totals.get("num_statements", 0),
            },
        }

        return json.dumps(result, separators=(",", ":"))

    def _generate_error_ndjson(self, error_message: str) -> str:
        """Generate NDJSON for error conditions."""
        result = {
            "test_execution": {
                "status": "error",
                "error_message": error_message,
                "exit_code": 1,
                "tests_run": 0,
                "tests_passed": 0,
                "tests_failed": 0,
                "execution_time": 0.0,
            },
            "coverage": {
                "overall_percentage": 0.0,
                "files_covered": 0,
                "lines_covered": 0,
                "lines_total": 0,
            },
        }

        return json.dumps(result, separators=(",", ":"))

    def run_specific_tests(self, test_files: List[str]) -> TestExecutionResult:
        """Run specific test files with coverage."""
        test_pattern = " ".join(test_files)
        return self.run_tests_with_coverage(test_pattern)

    def run_with_markers(self, markers: List[str]) -> TestExecutionResult:
        """Run tests with specific pytest markers."""
        marker_expr = " or ".join(markers)
        cmd_args = f"-m '{marker_expr}'"
        return self.run_tests_with_coverage(cmd_args)

    def generate_html_coverage_report(self) -> bool:
        """Generate HTML coverage report."""
        cmd = [
            sys.executable,
            "-m",
            "pytest",
            "--cov=src",
            "--cov-report=html:htmlcov",
            "--tb=no",  # No traceback for report generation
            str(self.tests_dir),
        ]

        try:
            result = subprocess.run(
                cmd,
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=120,
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, Exception):
            return False


def main():
    """Command-line interface for test runner."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Run tests with coverage reporting"
    )
    parser.add_argument("--pattern", help="Test pattern to run")
    parser.add_argument(
        "--min-coverage",
        type=float,
        default=80.0,
        help="Minimum coverage percentage",
    )
    parser.add_argument(
        "--html", action="store_true", help="Generate HTML coverage report"
    )
    parser.add_argument(
        "--markers", nargs="+", help="Run tests with specific markers"
    )

    args = parser.parse_args()

    runner = RunTest()

    if args.html:
        print("Generating HTML coverage report...")
        success = runner.generate_html_coverage_report()
        if success:
            print("HTML coverage report generated in htmlcov/")
        else:
            print("Failed to generate HTML coverage report")
            sys.exit(1)
        return

    if args.markers:
        result = runner.run_with_markers(args.markers)
    else:
        result = runner.run_tests_with_coverage(
            args.pattern, args.min_coverage
        )

    # Print results
    print("\nTest Results:")
    print(f"  Tests run: {result.tests_run}")
    print(f"  Passed: {result.tests_passed}")
    print(f"  Failed: {result.tests_failed}")
    print(f"  Coverage: {result.coverage_percentage:.1f}%")
    print(f"  Execution time: {result.execution_time:.2f}s")

    # Print NDJSON output
    print("\nNDJSON Output:")
    print(result.ndjson_output)

    sys.exit(result.exit_code)


if __name__ == "__main__":
    main()
